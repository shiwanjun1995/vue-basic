# 优先级 C 的规则：推荐 (将选择和认知成本最小化)

## 组件/实例的选项的顺序

组件/实例的选项应该有统一的顺序。

这是我们为组件选项推荐的默认顺序。它们被划分为几大类，你能够由此知道新的 property 应该被放到哪里。

```js
export default {
  name:'component', // 组件名
  components:{}, // 子组件
  directives:{}, // 自定义指令
  mixins:{}, // 混入
  provide/inject // 依赖注入
  props:{}, // 父组件传递的prop
  emits: [], // 组件定义的emit方法
  expose: {}, // 组件暴露出去的内容
  setup: {}, // 组合式 API
  data() {
    return {} // 本地状态
  },
  computed:{}, // 计算属性
  watch:{}, // 监听器 监听data里的一个属性
  created(){}, // 创建时的钩子
  mounted() {}, // 挂载时的钩子
  beforeUnmount(){}, // 销毁前的钩子
  methods: {}, // 方法
  render(h) {}, // 渲染函数
}
```

## 元素 attribute 的顺序

元素 (包括组件) 的 attribute 应该有统一的顺序。

这是我们为组件选项推荐的默认顺序。它们被划分为几大类，所以你也能知道新添加的自定义 attribute 和指令应该放到哪里。

```js
v-for
v-if、v-else-if、v-else、v-show
id
ref、key
v-model
其他属性
事件
v-html
```

## 组件/实例选项中的空行

你可能想在多个 property 之间增加一个空行，特别是在这些选项一屏放不下，需要滚动才能都看到的时候。

当你的组件开始觉得密集或难以阅读时，在多个 property 之间添加空行可以让其变得容易。在一些诸如 Vim 的编辑器里，这样格式化后的选项还能通过键盘被快速导航。

## 单文件组件的顶级元素的顺序

单文件组件应该总是让 <script>、<template> 和 <style> 标签的顺序保持一致。且 <style> 要放在最后，因为另外两个标签至少要有一个。

# 优先级 D 的规则：谨慎使用 (有潜在危险的模式)

## 没有在 v-if/v-else-if/v-else 中使用 key

如果一组 v-if + v-else 的元素类型相同，最好使用 key (比如两个 <div> 元素)。

默认情况下，Vue 会尽可能高效的更新 DOM。这意味着其在相同类型的元素之间切换时，会修补已存在的元素，而不是将旧的元素移除然后在同一位置添加一个新元素。如果本不相同的元素被识别为相同，则会出现意料之外的结果。

## scoped 中的元素选择器

元素选择器应该避免在 scoped 中出现。
在 scoped 样式中，类选择器比元素选择器更好，因为大量使用元素选择器是很慢的。

## 隐性的父子组件通信

应该优先通过 prop 和事件进行父子组件之间的通信，而不是 this.$parent 或变更 prop。
一个理想的 Vue 应用是 prop 向下传递，事件向上传递的。遵循这一约定会让你的组件更易于理解。然而，在一些边界情况下 prop 的变更或 this.$parent 能够简化两个深度耦合的组件。
问题在于，这种做法在很多简单的场景下可能会更方便。但请当心，不要为了一时方便 (少写代码) 而牺牲数据流向的简洁性 (易于理解)。

## 非 Flux 的全局状态管理

应该优先通过 Vuex 管理全局状态，而不是通过 this.$root 或一个全局事件总线。

通过 this.$root 和/或全局事件总线管理状态在很多简单的情况下都是很方便的，但是并不适用于绝大多数的应用。

Vuex 是 Vue 的官方类 flux 实现，其提供的不仅是一个管理状态的中心区域，还是组织、追踪和调试状态变更的好工具。它很好地集成在了 Vue 生态系统之中 (包括完整的 Vue DevTools 支持)。

## 3.x 版本中 v-if 总是优先于 v-for 生效。

并且 v-if 不再有访问 v-for 作用域的变量的权限，为了避免歧义，最好添加 template 标签或者使用计算属性来过滤 v-for 的数据源。

```js
在buildSlots函数中，先判断了v-if，然后再判断的v-for。这样做有几个原因：
1、更符合直觉，条件判断应该先于循环；
2、更好的性能，因为v-if是惰性的，只有当条件为真时才会渲染v-for循环，避免了不必要的渲染。
```
