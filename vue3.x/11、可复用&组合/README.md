# Mixin


## 基础
Mixin 提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能。一个 mixin 对象可以包含任意组件选项。当组件使用 mixin 对象时，所有 mixin 对象的选项将被“混合”进入该组件本身的选项。

## 不足
在 Vue 2 中，mixin 是将部分组件逻辑抽象成可重用块的主要工具。但是，他们有几个问题：

Mixin 很容易发生冲突：因为每个 mixin 的 property 都被合并到同一个组件中，所以为了避免 property 名冲突，你仍然需要了解其他每个特性。

可重用性是有限的：我们不能向 mixin 传递任何参数来改变它的逻辑，这降低了它们在抽象逻辑方面的灵活性。

为了解决这些问题，我们添加了一种通过逻辑关注点组织代码的新方法：组合式 API。

## 在组件中使用
和非 prop 的 attribute 类似，当在组件中使用时，自定义指令总是会被应用在组件的根节点上。
和 attribute 不同，指令不会通过 v-bind="$attrs" 被传入另一个元素。

有了片段支持以后，组件可能会有多个根节点。当被应用在一个多根节点的组件上时，指令会被忽略，并且会抛出一个警告。

## Composition API （组合式API）

## 1、为什么会有 Composition API?
```json
1、通过创建 Vue 组件，我们可以将界面中重复的部分连同其功能一起提取为可重用的代码段。仅此一项就可以使我们的应用在可维护性和灵活性方面走得相当远。然而，我们的经验已经证明，光靠这一点可能并不够，尤其是当你的应用变得非常大的时候——想想几百个组件。处理这样的大型应用时，共享和重用代码变得尤为重要。
2、如果能够将同一个逻辑关注点相关代码收集在一起会更好。而这正是组合式 API 使我们能够做到的。
```

## 2、组合式 API 基础

### 2.1、setup 组件选项（组合式API的使用位置）【搭配 <script setup></script> 使用，告诉vue需要在编译时进行一些处理，让我们可以更简洁地使用组合式API，比如其中的导入和顶层变量、函数都能够在模版中直接使用】
```json
1、新的 setup 选项在组件创建之前执行，一旦 props 被解析，就将作为组合式 API 的入口。
2、在 setup 中你应该避免使用 this，因为它不会找到组件实例。setup 的调用发生在 data property、computed property 或 methods 被解析之前，所以它们无法在 setup 中被获取。
3、setup 选项是一个接收 props 和 context 的函数，我们将在之后进行讨论。此外，我们将 setup 返回的所有内容都暴露给组件的其余部分 (计算属性、方法、生命周期钩子等等) 以及组件的模板。(以便其他组件选项可以对它们进行访问)
4、在 Vue 3.0 中，我们可以通过一个新的 ref 函数使任何响应式变量在任何地方起作用。(在任何值周围都有一个封装对象，这样我们就可以在整个应用中安全地传递它，而不必担心在某个地方失去它的响应性。换句话说，ref 为我们的值创建了一个响应式引用。在整个组合式 API 中会经常使用引用的概念。)
```

### 2.2、在 setup 内注册生命周期钩子
```json
1、组合式 API 上的生命周期钩子与选项式 API 的名称相同，但前缀为 on：即 mounted 看起来会像 onMounted。
2、onMounted 内部接收的是一个回调函数，onMounted()，内部可指定箭头函数或者在 setup 里定义的函数。（写入函数名即可，这些函数接受一个回调函数，当钩子被组件调用时将会被执行:）
```

### 2.3、watch 响应式更改
```json
就像我们在组件中使用 watch 选项并在 user property 上设置侦听器一样，我们也可以使用从 Vue 导入的 watch 函数执行相同的操作。它接受 3 个参数：
  1.一个想要侦听的响应式引用或 getter 函数
  2.一个回调
  3.可选的配置选项
```

### 2.4、独立的 computed 属性
```json
为了访问新创建的计算变量的 value，我们需要像 ref 一样使用 .value property。
```

## 3、Setup

### 3.1、参数
```json
1、使用 setup 函数时，它将接收两个参数：
  1.props
  2.context
2、setup 函数中的 props 是响应式的，当传入新的 prop 时，它将被更新。
3、但是，因为 props 是响应式的，你不能使用 ES6 解构，它会消除 prop 的响应性。（如果需要解构 prop，可以在 setup 函数中使用 toRefs 函数来完成此操作，另外如果传入的 prop 是可选的，则传入的 props 中可能没有该属性 。在这种情况下，toRefs 将不会为该属性创建一个 ref 。你需要使用 toRef 替代它）
4、传递给 setup 函数的第二个参数是 context。context 是一个普通的 JavaScript 对象，它暴露组件的三个 property：attrs, slots, emit（context 是一个普通的 JavaScript 对象，也就是说，它不是响应式的，这意味着你可以安全地对 context 使用 ES6 解构。）
```

### 3.2、访问组件的 property
```json
1、执行 setup 时，组件实例尚未被创建。因此，你只能访问以下 property：
  1.props
  2.attrs
  3.slots
  4.emit
2、换句话说，你将无法访问以下组件选项：
  1.data
  2.computed
  3.methods
```

### 3.3、结合模板使用
```json
注意，从 setup 返回的 refs 在模板中访问时是被自动浅解包的，因此不应在模板中使用 .value。
```

### 3.4、使用 this
```json
在 setup() 内部，this 不是该活跃实例的引用，因为 setup() 是在解析其它组件选项之前被调用的，所以 setup() 内部的 this 的行为与其它选项中的 this 完全不同。这使得 setup() 在和其它选项式 API 一起使用时可能会导致混淆。
```