## 自定义表单控件

一般来说，表单对应的一项是一个子项，但是在一些复杂情况下，一个item项会涉及到多个子项，这个时候可以自定义一个组件。使用 antdvue暴露出来的Form组件中的方法。

```vue
<template>
  <a-row
    v-for="(item, index) in value"
    :key="index"
    justify="space-between"
    class="mb-12"
  >
    <a-col :span="4">
      <a-select
        v-model:value="item.type"
        placeholder="类型"
        @change="onTypeChange($event, index)"
        :options="[
          { label: '精确', value: 'exact' },
          { label: '前缀', value: 'prefix' },
          { label: '正则', value: 'regex' },
        ]"
      >
      </a-select>
    </a-col>
    <a-col :span="8">
      <a-input
        v-model:value="item.key"
        placeholder="键"
        @change="onKeyChange($event, index)"
      ></a-input>
      <!-- 如果在事件名的括弧再包一层 ()，就会解构了 -->
    </a-col>
    <a-col :span="8" class="flx">
      <a-col flex="1">
        <a-input
          v-model:value="item.value"
          placeholder="值"
          @change="onValueChange($event, index)"
        ></a-input>
      </a-col>
      <a-col flex="32px">
        <IconMinusCircleOutlined
          v-if="value.length >= 1"
          @click="removePair(index)"
          class="minus-btn"
        />
      </a-col>
    </a-col>
  </a-row>
  <a-row>
    <a-button type="dashed" block @click="addPair">
      <IconPlus />
      新增键值
    </a-button>
  </a-row>
</template>

//
<!-- 自定义表单控件 自定义或第三方的表单控件，也可以与 Form
// 组件一起使用。只要该组件注入 useInjectFormItemContext 并调用相应方法。
// https://3x.antdv.com/components/form-cn/#components-form-demo-customized-form-controls
// 自 3.0 版本以后，Form.Item 不再劫持子元素，而是通过 provider / inject
// 依赖注入的方式进行自动校验，这种方式可以提高组件性能，子元素也不会限制个数，同样子元素也可以是进一步封装的高级组件。你可以参考自定义表单控件示例
// 但它同样会有一些缺点： 1、自定义组件如果希望 Form.Item 进行校验展示，你需要
// const {id, onFieldChange, onFieldBlur} = useInjectFormItemContext()
// 注入，并调用相应的方法。 2、一个 Form.Item
// 只能收集一个表单项的数据，如果有多个表单项，会导致收集错乱，
// 第三种，组件库提供了一个 a-form-item-rest
// 组件，它会阻止数据的收集，你可以将不需要收集校验的表单项放到这个组件中即可，它和第一种方式很类似，但它不会产生额外的
// dom 节点。 -->

<script setup>
import { Form } from 'ant-design-vue'

defineOptions({ name: 'CTypeKeyValuePair' })

const props = defineProps({
  value: [Array, Object],
})

const emit = defineEmits(['update:value'])

const formItemContext = Form.useInjectFormItemContext()

const triggerChange = (changedValue, curIndex) => {
  // 替换数组的某个元素
  const arrCopy = [...props.value]
  arrCopy.splice(curIndex, 1, { ...changedValue })
  emit('update:value', arrCopy)
  formItemContext.onFieldChange()
}

const onTypeChange = (e, curIndex) => {
  const curKey = props.value[curIndex].key
  const curValue = props.value[curIndex].value
  triggerChange({ key: curKey, value: curValue, type: e }, curIndex)
}

const onKeyChange = (e, curIndex) => {
  const curType = props.value[curIndex].type
  const curValue = props.value[curIndex].value
  triggerChange(
    { key: e.target.value, value: curValue, type: curType },
    curIndex,
  )
}
const onValueChange = (e, curIndex) => {
  const curType = props.value[curIndex].type
  const curKey = props.value[curIndex].key
  triggerChange({ key: curKey, value: e.target.value, type: curType }, curIndex)
}

const addPair = () => {
  props.value.push({
    key: '',
    value: '',
  })
  emit('update:value', props.value)
  formItemContext.onFieldChange()
}

const removePair = (curIndex) => {
  props.value.splice(curIndex, 1)
  emit('update:value', props.value)
  formItemContext.onFieldChange()
}
</script>

<style scoped lang="less">
// 通过子元素找父元素
.ant-col:has(> .minus-btn) {
  display: flex;
  justify-content: center;
}

.minus-btn {
  font-size: 24px;
  margin-top: 4px;
  cursor: pointer;
  color: @error-color;
}
</style>
```
