## 手动上传文件

要知道antdV中的a-upload组件，是通过 action 属性来指定上传的接口地址，然后直接触发上传到服务器，点击一次文件就向服务器上传一次文件，而尽管 multiple 属性也只是支持在选择的时候可以选择多个文件，选择好后也是直接上传，如果我们想要实现选择好文件后，等到其它的表单项都填写好，再一起点击上传，那么可以借助 customRequest 属性来实现自己的上传逻辑。

1、上传前，通过accept属性限制类型格式，通过beforeUpload方法来限制上传图片的大小

2、然后通过自定义方法customRequest的参数获取到文件内容file，把获取到的内容渲染到照片墙上，有的UI组件会返回图片的base64地址，但antdV没有返回，我们可以使用FileReader把图片转为base64地址或者其它格式。

3、获取到内容后，如果需要处理，那就使用自定义函数处理一下，赋值给对应的表单参数，或者按照服务端格式使用FormData把文件传到服务器上。

4、还可以使用数据请求api自带的onUploadProgress属性来对接口提交进度进行监听，从而实现上传百分比进度条。

## 案例1：上传文件或者目录到后端服务器

```vue
//
<!-- 上传弹窗 -->
<template>
  <a-modal
    v-model:visible="uploadModalState.visible"
    :title="uploadModalState.title"
    :width="600"
    centered
    class="center-modal"
  >
    <a-form
      ref="uploadModalFormRef"
      :model="uploadModalFormState"
      v-bind="submitFormItemLayout"
    >
      <a-form-item name="type" label="类型">
        <a-radio-group v-model:value="uploadModalFormState.type">
          <a-radio-button value="file">文件</a-radio-button>
          <a-radio-button value="folder">目录</a-radio-button>
        </a-radio-group>
      </a-form-item>
      <template v-if="uploadModalFormState.type === 'file'">
        <a-form-item name="files" label="文件" :rules="selectRule">
          <a-upload
            multiple
            :fileList="uploadModalFormState.files"
            :before-upload="beforeUpload"
            :custom-request="customRequest"
          >
            <a-button>
              <IconUpload />
              上传文件
            </a-button>
          </a-upload>
        </a-form-item>
      </template>
      <template v-if="uploadModalFormState.type === 'folder'">
        <a-form-item name="files" label="目录" :rules="selectRule">
          <a-upload
            directory
            :fileList="uploadModalFormState.files"
            :before-upload="beforeUpload"
            :custom-request="customRequest"
          >
            <a-button>
              <IconUpload />
              上传目录
            </a-button>
          </a-upload>
        </a-form-item>
      </template>
    </a-form>
    <template #footer>
      <a-button @click="uploadOnCancel">取消</a-button>
      <a-button
        type="primary"
        :loading="uploadModalState.submitLoading"
        @click="uploadOnOk"
        >确定</a-button
      >
    </template>
  </a-modal>
</template>

<script setup>
const uploadModalState = reactive({
  visible: false,
  title: undefined,
  modalType: undefined,
  modalId: undefined,
  modalLoading: false,

  submitLoading: false,
})

onUpload = () => {
  uploadModalState.visible = true
  uploadModalState.title = '上传信息'
}

const uploadModalFormRef = ref()
const uploadModalFormState = reactive({
  type: 'file',
  files: [],
})

const uploadOnCancel = () => {
  uploadModalState.visible = false
}

const uploadOnOk = () => {
  uploadModalFormRef.value.validateFields().then(() => {
    uploadModalState.visible = false
    onFilter(true)
  })
}

watch(
  () => uploadModalState.visible,
  (newVal, _val) => {
    if (!newVal) {
      uploadModalFormRef.value.resetFields()
    }
  },
)

const beforeUpload = (file, _) => {
  return new Promise((resolve, reject) => {
    const isMaxSize = file.size / 1024 / 1024 < 100
    if (!isMaxSize) {
      message.error('最大文件大小仅支持100M，请重新上传')
      return reject()
    }

    return resolve(file)
  })
}

const customRequest = async ({ file }) => {
  const formData = new FormData()
  formData.append('podName', podName)
  formData.append('containerName', containerName)
  formData.append('path', nestState.curentPath)
  formData.append('files', file)
  // console.log(formData)
  // console.log(file)

  const params = { ...xxx }

  const config = {
    headers: { 'Content-Type': 'multipart/form-data' },
    timeout: 0,
  }
  const res = await INTERFACE.xxxx(params, formData, config)
  if (res.code === 0) {
    file.status = 'success'
    uploadModalFormState.files.push(file)
    // 坑：这里是一个异步的操作
    uploadModalFormRef.value.clearValidate(['files'])
    message.success('上传成功，可继续上传。')
  } else {
    file.status = 'error'
  }
}
</script>
```

## 案例2：上传excel，前端识别文件格式，并转换成服务端要求的格式值

```vue
<template>
  <div class="c-excel-upload">
    <a-upload
      :name="'file'"
      :multiple="false"
      accept=".xlsx,.xls"
      :show-upload-list="false"
      :before-upload="handleBeforeUpload"
      :custom-request="handleUpload"
      :disabled="disabled"
    >
      <a-button type="primary" :disabled="disabled || loading">
        <upload-outlined /> {{ loading ? '上传中...' : '上传Excel文件' }}
      </a-button>
    </a-upload>

    <div v-if="parseResult.length > 0" class="parse-result">
      <h4>解析结果（共 {{ parseResult.length }} 行）：</h4>
      <a-table
        :columns="columns"
        :data-source="parseResult"
        :pagination="{ pageSize: 10 }"
        :scroll="{ x: 500 }"
        size="small"
      >
        <template #bodyCell="{ column, record }">
          <template v-if="column.key === 'status'">
            <a-tag :color="record.status === 'success' ? 'green' : 'red'">
              {{ record.status === 'success' ? '通过' : '失败' }}
            </a-tag>
          </template>
        </template>
      </a-table>
    </div>

    <div v-if="errorMessage" class="error-message">
      <a-alert type="error" :message="errorMessage" banner />
    </div>
  </div>
</template>

<script setup>
import { ref, watch } from 'vue'
import { UploadOutlined } from '@ant-design/icons-vue'
import { message } from 'ant-design-vue'
import * as XLSX from 'xlsx'

// Props
const props = defineProps({
  value: {
    type: Array,
    default: () => [],
  },
  strictString: {
    type: Boolean,
    default: true,
  },
  accept: {
    type: String,
    default: '.xlsx,.xls',
  },
  maxSize: {
    type: Number,
    default: 10, // MB
  },
  disabled: {
    type: Boolean,
    default: false,
  },
})

// Emits
const emit = defineEmits(['update:value', 'change'])

// State
const loading = ref(false)
const parseResult = ref([])
const errorMessage = ref('')

// Columns for result table
const columns = [
  { title: '行号', dataIndex: 'row', key: 'row', width: 80 },
  { title: '内容', dataIndex: 'content', key: 'content', width: 300 },
  { title: '类型', dataIndex: 'type', key: 'type', width: 120 },
  { title: '状态', dataIndex: 'status', key: 'status', width: 100 },
]

// 生成解析结果显示
const generateParseResult = (data) => {
  parseResult.value = data.map((item, index) => {
    const type = typeof item
    const status = props.strictString
      ? type === 'string'
        ? 'success'
        : 'error'
      : 'success'

    return {
      row: index + 1,
      content: item,
      type: type,
      status: status,
    }
  })
}

// Watch value changes
watch(
  () => props.value,
  (newVal) => {
    if (newVal && newVal.length > 0) {
      generateParseResult(newVal)
    } else {
      parseResult.value = []
    }
  },
  { immediate: true, deep: true },
)

// Before upload check
const handleBeforeUpload = (file) => {
  // Check file type
  const isExcel = /\.(xlsx|xls)$/.test(file.name.toLowerCase())
  if (!isExcel) {
    message.error('请上传Excel文件(.xlsx或.xls格式)')
    return false
  }

  // Check file size
  const isLtMaxSize = file.size / 1024 / 1024 < props.maxSize
  if (!isLtMaxSize) {
    message.error(`文件大小不能超过 ${props.maxSize}MB`)
    return false
  }

  return true
}

// Handle file upload
const handleUpload = async (options) => {
  const file = options.file
  loading.value = true

  return new Promise((resolve, reject) => {
    const reader = new FileReader()

    reader.onload = (e) => {
      try {
        const data = e.target.result
        const result = parseExcelData(data)
        emit('update:value', result)
        // 添加这一行，触发change事件
        emit('change')

        message.success('Excel文件解析成功')
        errorMessage.value = ''
        resolve(result) // 解析完成后resolve
      } catch (error) {
        emit('update:value', undefined)
        errorMessage.value = error.message
        message.error('Excel文件解析失败，必须为一列多行格式')
        reject(error)
      } finally {
        loading.value = false
      }
    }

    reader.onerror = () => {
      const error = new Error('文件读取失败')
      errorMessage.value = error.message
      message.error('文件读取失败')
      reject(error)
      loading.value = false
    }

    reader.readAsArrayBuffer(file)
  })
}

// Excel解析函数
const parseExcelData = (data) => {
  // 使用xlsx库解析Excel文件
  const workbook = XLSX.read(data, { type: 'array' })
  const firstSheetName = workbook.SheetNames[0]
  const worksheet = workbook.Sheets[firstSheetName]

  // 转换为JSON格式
  const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1 })

  // 验证Excel格式是否为一列多行
  validateExcelFormat(jsonData)

  // 提取第一列数据
  const firstColumnData = jsonData.map((row) => row[0])

  // 过滤空值
  const validData = firstColumnData.filter(
    (item) => item !== null && item !== undefined && item !== '',
  )

  generateParseResult(validData)

  return validData
}

// 验证Excel格式是否为一列多行
const validateExcelFormat = (jsonData) => {
  // 检查是否有数据
  if (jsonData.length === 0) {
    throw new Error('Excel文件为空')
  }

  // 检查是否有超过一列的数据
  const hasMultipleColumns = jsonData.some((row) => row.length > 1)
  if (hasMultipleColumns) {
    throw new Error('Excel文件格式错误：仅支持一列多行格式')
  }

  // 检查是否有数据行
  const hasData = jsonData.some(
    (row) => row[0] !== null && row[0] !== undefined && row[0] !== '',
  )
  if (!hasData) {
    throw new Error('Excel文件中没有有效数据')
  }
}
</script>

<style scoped>
.c-excel-upload {
  display: flex;
  flex-direction: column;
  gap: 16px;
}

.parse-result {
  margin-top: 16px;
}

.error-message {
  margin-top: 16px;
}
</style>
```

// 参考链接：https://juejin.cn/post/7032949246718377991
