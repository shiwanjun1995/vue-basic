# 混入
当组件使用混入对象时， 所有混入对象的选项将被“混合”进入该组件本身的选项

## 选项合并
当组件和混入对象含有同名选项时，这些选项中的数据对象会在内部进行递归合并，并在发生冲突时以组件数据优先

同名钩子函数将合并为一个数组，因此都将被调用。另外，混入对象的钩子将在组件自身钩子之前调用。值为对象的选项，例如 methods、components 和 directives，将被合并为同一个对象。两个对象键名冲突时，取组件对象的键值对。

## 全局混入
混入也可以进行全局注册。使用时格外小心！一旦使用全局混入，它将影响每一个之后创建的 Vue 实例。使用恰当时，这可以用来为自定义选项注入处理逻辑。
请谨慎使用全局混入，因为它会影响每个单独创建的 Vue 实例 (包括第三方组件)。大多数情况下，只应当应用于自定义选项，就像上面示例一样。推荐将其作为插件发布，以避免重复应用混入。


# 自定义指令
对普通 DOM 元素进行底层操作，这时候就会用到自定义指令
自定义指令包含两个参数 1：参数名字（注意不用加上v-） 2：第二个参数是一个对象 在这个对象上有一些指令相关的函数 这些函数可以在特定阶段执行相关的操作（钩子函数）

## 钩子函数理解
一个指令定义对象可以提供如下几个钩子函数 (均为可选)：
* bind: 只调用一次 当指令绑定到这个元素上的时候 会立即执行这个bind函数

* inserted: 元素插入到了DOM中 会会执行inserted这个函数 只触发一次 el表示指令所绑定的原生对象 可以直接操作dom

# 渲染函数&JSX
Vue 推荐在绝大多数情况下使用模板来创建你的 HTML。然而在一些场景中，你真的需要 JavaScript 的完全编程的能力。这时你可以用渲染函数，它比模板更接近编译器。

## 虚拟DOM
Vue 通过建立一个虚拟 DOM 来追踪自己要如何改变真实 DOM。

createElement 到底会返回什么呢？其实不是一个实际的 DOM 元素。它更准确的名字可能是 createNodeDescription，因为它所包含的信息会告诉 Vue 页面上需要渲染什么样的节点，包括及其子节点的描述信息。我们把这样的节点描述为“虚拟节点 (virtual node)”，也常简写它为“VNode”。“虚拟 DOM”是我们对由 Vue 组件树建立起来的整个 VNode 树的称呼。

# 插件
Vue.js 的插件应该暴露一个 install 方法。这个方法的第一个参数是 Vue 构造器，第二个参数是一个可选的选项对象：

# 过滤器
Vue.js 允许你自定义过滤器，可被用于一些常见的文本格式化。过滤器可以用在两个地方：双花括号插值和 v-bind 表达式 过滤器应该被添加在 JavaScript 表达式的尾部，由“管道”符号指示：

也就是管道符号前的值会作为过滤器函数的参数

# 深入响应式原理
每个组件的实例都对应一个 watcher实例 它会在组件渲染的过程中把“接触”过的属性记录为依赖 之后当依赖项的setter属性发生变化的时候 会通知到watcher实例 从而使它关联的组件重新渲染

由于 JavaScript 的限制，Vue 不能检测数组和对象的变化。

* 对于对象：this.$set(this.obj,'b',2) 有时你可能需要为已有对象赋值多个新属性，比如使用 Object.assign() 或 _.extend()。但是，这样添加到对象上的新属性不会触发更新。在这种情况下，你应该用原对象与要混合进去的对象的属性一起创建一个新的对象。 this.obj = Object.assign({},this.obj,'b',2)

* 数组：Vue 不能检测以下数组的变动：

当你利用索引直接设置一个数组项时，例如：vm.items[indexOfItem] = newValue
当你修改数组的长度时，例如：vm.items.length = newLength

## 异步更新队列
可能你还没有注意到，Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。

因为 $nextTick() 返回一个 Promise 对象，所以你可以使用新的 ES2017 async/await 语法完成



