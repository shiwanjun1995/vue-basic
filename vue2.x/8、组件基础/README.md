# 组件化

## 什么是组件化
将页面中的功能进行拆分，每一个功能单独存储成为一个组件，这个过程就是所谓的组件化！组件中包含html,css,javascript代码！

## 组件化和模块化的联系与区别
组件化和模块化都是用来实现代码复用的！组件所包含的内容要比模块大一些，组件中可能会引用到模块！

## 组件化的意义
vue中一般的开发模式都是组件化！
1. 便于功能复用
2. 便于人员分工
3. 代码结构更加清晰，便于维护！

## 注册组件的方式
* 全局注册  
  注意名字 写的时候是什么名字 引用的时候就写什么名字
```js
Vue.component('组件名',{
    data() {
        return {'数据'}
    }
    template: '模板'
})
```
* 局部注册
  注意名字现在是驼峰命名法
```js
components: {
    myheader: {
        template: "<div>登录组件</div>"
    }
}
```

### 注意点：
* data选项 必须是一个函数 
* 因为组件可以有很多个实例，如果data是一个对象，则每个实例用到的都是同一个对象，那么在一个实例中对数据进行修改，会导致其他所有实例中的数据都发生变化。
* 所以我们需要将data写成一个函数，在组件实例被创建的时候，会执行一次data函数，data函数中会返回一个新的唯一的对象，那么每个组件实例都会拥有自己的data实例了，所以互不干扰了！
* 因此每个实例可以维护一份被返回对象的独立的拷贝
如果vue没有这条规则 点击一个按钮就可能会像如下代码一样影响到其它所有的实例
```js
  data () {
      return {
          count: 0
      }
  }
```

## 组件的组织
通常一个应用会以一棵嵌套的组件树的形式来组织：每个组件内有包含了其它引用到的组件
而为了能在模板中使用 这些组件必须先注册以便能够让vue识别 这里注册组件有两种类型：全局注册以及局部注册

全局注册：全局注册的组件可以用在其被注册之后的任何 (通过 new Vue) 新创建的 Vue 根实例，也包括其组件树中的所有子组件的模板中。
局部注册：

# 父组件向子组件传值 prop [属性]

## 通过 Prop 向子组件传递数据
组件上注册的自定义特性 ===> 传递给一个 prop 特性的时候 它就变成了那个组件实例的一个属性 
组件实例的作用域是相互独立的 子组件内的模板无法直接引用父组件内的数据 子组件想要使用父组件的数据 <=== 父组件 需要通过子组件的 props 选项

### 静态props
* 静态Prop通过为子组件在父组件中的占位符添加特性的方式来达到传值的目的 
* 对于props声明的属性来说，在父级HTML模板中，属性名需要使用中划线写法
* 子级props属性声明时，使用小驼峰或者中划线写法都可以；而子级模板使用从父级传来的变量时，需要使用对应的小驼峰写法

### 动态props
在模板中，要动态地绑定父组件的数据到子模板的 props，与绑定到任何普通的HTML特性相类似，就是用 v-bind。每当父组件的数据变化时，该变化也会传导给子组件 让它的值被当作JS表达式计算 

### 验证props 如果使用的是开发版本
可以为组件的 props 指定验证规格。如果传入的数据不符合规格，Vue会发出警告。当组件给其他人使用时，这很有用 要指定验证规格，需要用对象的形式，而不能用字符串数组 当 prop 验证失败，Vue 会在抛出警告 (如果使用的是开发版本)。props会在组件实例创建之前进行校验，所以在 default 或 validator 函数里，诸如 data、computed 或 methods 等实例属性还无法使用

### 修改props(指的是子修改父)
一般情况子组件拿到 父亲传的 props 值直接显示数据，也有少数需在 子组件修改参数。
子组件中修改prop中的数据，通常有以下两种原因
1、prop 作为初始值传入后，子组件想把它当作局部数据来用
2、prop 作为初始值传入，由子组件处理成其它数据输出

一个组件默认可以拥有任意数量的 prop，任何值都可以传递给任何 prop
注意事项：
* 父组件给子组件传参 
* 数据从父组件传递给子组件 只能单向绑定
* 在子组件内不应该修改父组件传递过来的数据（如有特殊情况需要改变）
  
## 父组件、子组件概念
组件（父）中引入另一个组件（子）

## 单个根元素
当构建一个 <blog-post> 组件时，你的模板最终会包含的东西远不止一个标题：还需要发布日期、评论等。为每个相关的信息定义一个prop就会变得很麻烦：让它接收一个post属性 其值是一个对象

## 监听子组件的事件
当我们开发一个需要在多处引用到的重复组件的时候 它的一些功能可能要求我们和父级组件进行沟通 当子组件内部触发了一个事件后 外部（也就是调用子组件的父级组件）应该能相应的感知到事件的触发，从而再出发一些列的操作。

例如：子组件为一个按钮，当按钮被点击时，父级组件会感知，并触发想要触发的操作。v-on 操作可以用来监听某些预设好的事件 比如input、change、click事件 同时也支持访问自定义的事件 所以，当我们调用已注册的组件，如<blog-post>组件，我们可以用v-on为组件预先绑定一个自定义的事件监听器，只要这个自定义事件被触发了，父级组件就会感知到，触发一个操作。具体的预先设置如下：

尽管在子组件里面写了这个按钮 但这个按钮并不会做任何事：
```js
    <button>
        Enlarge text
    </button>
```
当点击按钮的时候 需要告诉父级组件放大所有博文的文本。幸好 Vue 实例提供了一个自定义事件的系统来解决这个问题。父级组件可以像处理 native DOM 事件一样通过 v-on 监听子组件实例的任意事件：
```js
<blog-post
  v-on:enlarge-text="postFontSize += 0.1"
></blog-post>
```
同时子组件可以通过调用内建的 $emit 方法 并传入事件名称来触发一个事件：
```js
    <button v-on:click="$emit('enlarge-text')">
        Enlarge text
    </button>
```
有了这个 v-on:enlarge-text="postFontSize += 0.1" 监听器，父级组件就会接收该事件并更新 postFontSize 的值。

## 使用事件添加一个参数
```js
    <button v-on:click="$emit('enlarge-text', 0.1)">
        Enlarge text
    </button>
```
触发的时候 在父组件给子组件传入一个事件 并添加这个参数
### 注意  $emit传入的事件名称只能使用小写，不能使用大写的驼峰规则命名 模板和触发的方法名都要改成小写！！！

### 具体的实现思路 父组件传参 子组件拿值
1.设定埋伏 准备捕捉子组件的操作 父组件在子组件上添加 v-on 自定义函数
2.子组件进行操作 告知父组件 子组件内部设置这个自定义事件是如何触发 $emit

过程 当子组件的按钮被点击时 ==> 触发 $emit('短横线链接起来的事件名') ==> 间接触发了 短横线链接起来的事件名 自定义事件 ==> 然后触发父组件调用子组件时设置的 v-on:短横线链接起来的事件名 === 最终触发了相应的函数

解释：要注意$emit只是用来触发一个自定义的事件，这个事件对应外部父组件调用子组件时，对子组件添加的v-on所监听的事件，$emit并不能触发任何函数操作，仅仅如同一个触发器。

## 子组件传递数据给父组件（添加第二个参数）
两种方式 
* 一种是直接在子组件后 @click="$emit('send-msg',参数)"
* 另外是写一个事件名 this.$emit(事件名称, 参数) 这个是用来触发事件的！

参考链接：1.https://www.jianshu.com/p/d0cc6eb0226e 2.https://www.cnblogs.com/xiaohuochai/p/7388866.html

# 解析 DOM 模板时的注意事项

## 大小写不敏感
另外，HTML attribute 名不区分大小写，因此浏览器将所有大写字符解释为小写。这意味着当你在 DOM 模板中使用时，驼峰 prop 名称和 event 处理器参数需要使用它们的 kebab-cased (横线字符分隔) 等效值：

```js
//  在 JavaScript 中是驼峰式

app.component('blog-post', {
  props: ['postTitle'],
  emits: ['enlargeText'],
  template: `
    <h3>{{ postTitle }}</h3>
  `
})
```

```html
<!-- 在 HTML 中则是横线字符分割 -->
<blog-post post-title="hello!" @enlarge-text="enlargeText"></blog-post>
```

