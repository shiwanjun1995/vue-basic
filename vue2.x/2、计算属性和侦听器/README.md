## 计算属性
{{}}模板内的表达式非常便利 但是其设计初衷是用于简单运算 如果涉及到太多的逻辑便会很难维护 对于任何复杂辑，你都应当使用计算属性。

可以像绑定普通属性一样在模板中绑定计算属性 vue知道vm.newinfo依赖于vm.info 因此当vm.info的值发生改变时 所有vm.newinfo的绑定也会更新 也是一个属性，也是用来存储数据用的 但是和data属性相比还是有区别
* 1 数据是可以进行逻辑处理相关的操作
* 2 可以对计算属性中的数据进行监视
  必须是一个有返回值的方法


### 计算属性缓存 vs 方法
```html
在表达式中调用这个方法来达到同样的效果
<h2>{{newinfo()}}</h2>

```js
methods: {
    newinfo() {
        return this.info.split('').reverse().join('')
    }
}
```

### 计算属性和方法的区别？
* 计算属性是基于它们的响应式依赖进行缓存的 只有在相关响应式依赖发生改变时它们才会重新求值 而普通的方法每次都会执行（这就意味着只要info的值还（如果是动态的话）没有发生改变 多次访问newinfio计算属性 就会立即返回之前的计算结果 而不必再次执行函数）
* 计算属性是有缓存的 只要它依赖的数据没有发生改变 后面的每一次访问计算属性的值 都是之前缓存的结果 不会重复执行数据操作
* 计算属性默认只有getter 有需要的话可以设置一个setter 只要任何值有更新 那么所有在computed计算属性里和其相关的值都会更新
* methods 只要发生重新渲染 method 调用总会执行该函数 (比如该函数reverseMsg1() 一直重复执行 因为页面的msg数据 发生了改变 重新渲染了) 不会自动同步数据 

总结：
* methods是交互方法 需要主动去触发 而computed则是检测到data数据有相关依赖项发生变化时就会自动触发
* methods是一次性的无缓存的计算 computed则是有缓存的 
* methods每次计算后都会把变量进行回收 再次访问的时候会重新计算 而computed则是依赖数据的 数据占用内存是不会被回收 再次访问的时候不会被重新计算 而是返回上次计算的值 当依赖的数据发生变化 才会再次计算
* 计算属性computed和methods都不应该使用箭头函数来定义 因为箭头函数绑定了父级作用域的上下文，所以 this 将不会按照期望指向Vue
* 调用方式不一样，computed定义的成员像属性一样访问，methods定义的成员必须以函数形式调用
* 计算属性通过其他变量计算得来的另一个属性 因此它具有依赖性
* computed有缓存机制 如果使用的data没有发生变化的话 改变其它变量的值 是不需要重新计算 而在methods中会重复计算

* watch适合处理的场景是 侦听一个数的变化 当该数据变化 来处理其他与之相关数据的变化（该数据影响别的多个数据）== 当数据发生变化时 执行异步操作或较大开销操作的情况 允许我们执行异步操作
* computed适合处理的场景是 一个数据属性在它所依赖的属性发生变化时 也要发生变化 这种情况下 我们最好使用计算属性
* 如果在data中没有相应的属性的话，是不能watch的，这点和computed不一样
```
